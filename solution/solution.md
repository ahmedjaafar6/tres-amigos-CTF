# Tres Amigos

Authors: [Ahmed Jaafar](https://github.com/ahmedjaafar6)

## Description
All 4 C programs are provided to the attacker along with the executables/binaries of all 4 programs.

Part 1: In order for the first part's flag to be printed, only the letter 'a' must be in the destination.txt. The file cannot simply be edited and an 'a' manually be put there because the code checks for that at the start. The attacker must take advantage of the 5 second sleep and edit the file programatically. In destination.txt, the encrypted text must be decrypted because the plaintext will be useful in part 3. So it's best to decrypt first then edit the file.

Part 2: The flag from part 1 must be entered first. Then the attacker must take advantage of strcpy() since it's vulernable to a buffer overflow attack. The attacker needs to input past the 12 limit buffer (buf variable) in order to reach the foo variable. The attacker can input any character or set of characters except 0.

Part 3: The flag from part 2 must be entered first. In order to get the flag, buf must equal to the decrypted text from part 1. Since there is no user input for an attacker to exploit the program that way, an attacker must find another way. The attacker needs to open up the executable/binary file and change buf through there.


## Exploit
Part 1: destination.txt was encrypted using the gpg tool with the password "DRWILHO" which is a permuation of "HIWORLD". The attacker must first get the correct password. In order to do that, they can use a file with a list of "HIWORLD" permuations (One per line), generated by let's say crunch. Then they need to code a program, I used python, that takes that list and feeds it into the running get_password.c program. If the correct perumation is in the file, the program should tell them that that one is correct. A sleep() is used in between tries to give get_password.c time to check if an attempt is correct or not.

```
crunch 0 0 -o pass-list.txt -p HIWORLD
```

```
import time

with open("./pass-list.txt") as file:
    lines = [line.rstrip() for line in file]

for i in lines:
    print(i)
    time.sleep(0.2)
```

Part 1 Continued: Once the correct password is found, gpg should be used to decrypt the file. That can be done with a command. The command will pop up a window that will ask for the password, in which the attacker can put the password found earlier. If the password is correct, then the attacker will be prompted to name the decrypted file something. A file with the decrypted text will be generated.

```
gpg destination.txt
```

Part 1 Continued: Since 5 seconds is too short of a gap for an attacker to manually delete the encrypted text and replace it with the letter 'a' in the destination.txt file, they must code a program, I used python, that does that. That program must be launched seperately within that 5 second timeframe.

```
with open("./test.txt", "w+") as file:
     file.write("a")
file.close()
```

Part 2: The attack must see how far apart buf and foo are from each other in memory. That can be done using gdb. Start gdb on part2 object file and set a breakpoint anywhere after buf and foo are declared. Run gdb on the program until it halts at the breakpoint. Use commands inside gdb to get the addresses of buf and foo. The addresses will be in hex. Convert the hex to decimal using any tool like the one found [here](https://www.rapidtables.com/convert/number/hex-to-decimal.html). Find the difference between the two decimal addresses to see how many bytes are in between buf and foo, if there are any.

```
p &buf
p &foo

```

Part 2 Continued: Enter into the awaiting scanner in the command line 12 characters to fill the sized 12 buffer, followed by x amount of characters, where x represents the gap length between foo and buf (5 in the example below), if there is any. Finally, enter any character or characters other than 0 to make foo true for it to pass the condition.

```
jjjjjjjjjjjjkkkkk1

```

Part 3: Any binary/hex viewer that also shows the equivalent readable text can be used on the executable/binary file. I used hexedit (Command to start it up shown below). hexedit shows the hex on the left side and the equivlent readable text on the right side. The attacker needs to find "Ahmed" on the right, and change it to "Bingo" which is the decrypted text from part 1. The attacker must not add any character more or less, because if they do they would have to also have to deal with changing stuff in the section headers. "Ahmed" and "Bingo" were picked on purpose to have the same length to not have the attacker be required to mess with the section headers. Once saved and ran again, the final flag should print. 
Note: If the attacker wants to compile part3.c on their machine and try editing the executable/binary, part3.c must be compiled with clang rather than gcc, that way the buf variable can be displayed in the hex editor. Although that shouldn't be necessary because the already compiled executable/binary will be provided.

```
hexedit part3
```
